## 面试常见问题

### FPGA详细设计流程

与数字IC设计流程类似，以xilinx vivado工具为例，主要有以下步骤：系统规划、RTL输入、行为仿真、逻辑综合、综合后仿真（可选）、综合后设计分析（时序及资源）、设计实现（包括布局布线及优化）、实现后设计分析（时序及资源）、板级调试、bitstream固化。

### FPGA结构一般分为哪三个部分

1. 可编程逻辑块（LAB）
2. 可编程I/O模块
3. 可编程内部连线

### Latch和Register区别？行为描述中Latch如何产生？

本质的区别在于：
latch是电平触发，reg是边沿触发。时序设计中尽量使用reg触发。行为描述中，如果对应所有可能输入条件，有的输入没有对应明确的输出，系统会综合出latch。

### Latch是什么

Latch其实就是锁存器，是一种在异步电路系统中，对输入信号电平敏感的单元，用来存储信息。锁存器在数据未锁存时，输出端的信号随输入信号变化，就像信号通过一个缓冲器，一旦锁存信号有效，则数据被锁存，输入信号不起作用。因此，锁存器也被称为透明锁存器，指的是不锁存时输出对于输入是透明的。

### Latch的危害

之所以在这里讲关于Latch的问题是因为只有组合逻辑才会产生这种问题，产生Latch是我们在同步电路中尽量避免的，但并不表示Latch没有用的或者说是错误的，Latch在异步电路中是非常有用的，只是我们设计的是同步电路，要尽量避免。

在同步电路中Latch会产生不好的效果，如对毛刺敏感；不能异步复位，上电后处于不定态；还会让静态时序分析变得十分复杂；在FPGA的资源中，大部分器件没有锁存器这个东西，所以需要用使用寄存器来组成锁存器所以会占用更多逻辑资源；在ASIC设计中，锁存器也会带来额外的延时和DFT，并不利于提高系统的工作频 率，所以要避免产生。在这里我们把会产生组合逻辑的几种情况列举出来，希望大家以后能够避免出现类似的问题。

### 几种产生Latch的情况

关于Latch的介绍如果能够理解原理最好，如对原理理解不透彻可以先记住规范的写法，避免产生不可控的因素，从而综合出更好的电路。以下不规范的3种产生Latch的写法一定要尽量避免。

- 组合逻辑中if语句没有else；

- 组合逻辑中case的条件不能够完全列举时且不写default；

- 组合逻辑中输出变量赋值给自己。



### 对竞争冒险的理解，以及如何消除？

在组合逻辑中，由于门的输入信号通路中经过了不同的延时，导致到达该门的时间不一致叫**竞争**。产生毛刺叫**冒险**。如果布尔式中有相反的信号则可能产生竞争和冒险现象。解决方法：
一是添加布尔式的消去项，二是在芯片外部加电容。

### 同步/异步

**同步电路**：存储电路中所有触发器的时钟输入端都接同一个时钟脉冲源，因而所有触发器的状态的变化都与所加的时钟脉冲信号同步。
**异步电路**：电路没有统一的时钟，有些触发器的时钟输入端与时钟脉冲源相连，只有这些触发器的状态变化与时钟脉冲同步，而其他的触发器的状态变化不与时钟脉冲同步。



### 什么是同步逻辑和异步逻辑

同步逻辑是时钟之间有固定的因果关系。异步逻辑是各时钟之间没有固定的因果关系。
同步时序逻辑电路的特点：各触发器的时钟端全部连接在一起，并接在系统时钟端，只有当时钟脉冲到来时，电路的状态才能改变。改变后的状态将一直保持到下一个时钟脉冲的到来，此时无论外部输入 x 有无变化，状态表中的每个状态都是稳定的。
异步时序逻辑电路的特点：电路中除可以使用带时钟的触发器外，还可以使用不带时钟的触发器和延迟元件作为存储元件，电路中没有统一的时钟，电路状态的改变由外部输入的变化直接引起。

### 异步信号同步方式

单比特数据，打两拍后检测打拍后信号变化沿。若快时钟域信号进入慢时钟域，则先扩展位宽再打两拍。
多比特数据，使用异步FIFO桥接。在数据量不大，带宽要求不高的场合可以采用握手同步方式（利用单比特握手信号打两拍同步方式找到数据稳定时刻，保证上游握手信号拉高时数据稳定不变）。

### 对于多位的异步信号如何进行同步

对以一位的异步信号可以使用“一位同步器进行同步”（使用两级触发器），而对于多位的异步信号，可以采用如下方法：
1：可以采用保持寄存器加握手信号的方法（多数据，控制，地址）；
2：特殊的具体应用电路结构,根据应用的不同而不同；
3：异步FIFO。（最常用的缓存单元是DPRAM）。

### FPGA设计中如何实现同步时序电路的延时

首先说说异步电路的延时实现：异步电路一半是通过加buffer、两级与非门等来实现延时（我还没用过所以也不是很清楚），但这是不适合同步电路实现延时的。在同步电路中，对于比较大的和特殊要求的延时，一半通过高速时钟产生计数器，通过计数器来控制延时；对于比较小的延时，可以通过触发器打一拍，不过这样只能延迟一个时钟周期。


### 时序设计的实质

时序设计的实质就是满足每一个触发器的建立/保持时间的要求。

### 建立时间与保持时间的概念

建立时间：触发器在时钟上升沿到来之前，其数据输入端的数据必须保持不变的最小时间。
保持时间：触发器在时钟上升沿到来之后，其数据输入端的数据必须保持不变的最小时间。



### 为什么触发器要满足建立时间和保持时间

因为触发器内部数据的形成是需要一定的时间的，如果不满足建立和保持时间，触发器将进入亚稳态，进入亚稳态后触发器的输出将不稳定，在0和1之间变化，这时需要经过一个恢复时间，其输出才能稳定，但稳定后的值并不一定是你的输入值。这就是为什么要用两级触发器来同步异步输入信号。这样做可以防止由于异步输入信号对于本级时钟可能不满足建立保持时间而使本级触发器产生的亚稳态传播到后面逻辑中，导致亚稳态的传播。


### SRAM和DRAM的区别

SRAM是静态随机访问存储器，由晶体管存储数据，无需刷新，读写速度快。DRAM是动态随机访问存储器，由电容存储数据，由于电容漏电需要动态刷新，电容充放电导致读写速度较SRAM低。但DRAM成本较低，适合做大容量片外缓存。



### 亚稳态

在异步系统中，寄存器建立保持时间不满足引起亚稳态。典型的场合为数据跨时钟域传输和异步复位电路。在异步传输过程中，通过单比特信号双寄存器同步，多比特信号FIFO桥接的方式消除亚稳态（实际上异步信号同步方式即为异步传输过程中亚稳态的消除方式）。通过异步复位，同步释放可消除异步复位引起的亚稳态。

### 什么是亚稳态为什么两级触发器可以防止亚稳态传播

这也是一个异步电路同步化的问题。亚稳态是指触发器无法在某个规定的时间段内到达一个可以确认的状态。使用两级触发器来使异步电路同步化的电路其实叫做“一位同步器”，他只能用来对一位异步信号进行同步。两级触发器可防止亚稳态传播的原理：假设第一级触发器的输入不满足其建立保持时间，它在第一个脉冲沿到来后输出的数据就为亚稳态，那么在下一个脉冲沿到来之前，其输出的亚稳态数据在一段恢复时间后必须稳定下来，而且稳定的数据必须满足第二级触发器的建立时间，如果都满足了，在下一个脉冲沿到来时，第二级触发器将不会出现亚稳态，因为其输入端的数据满足其建立保持时间。同步器有效的条件：第一级触发器进入亚稳态后的恢复时间 + 第二级触发器的建立时间 < = 时钟周期。
更确切地说，输入脉冲宽度必须大于同步时钟周期与第一级触发器所需的保持时间之和。最保险的脉冲宽度是两倍同步时钟周期。 所以，这样的同步电路对于从较慢的时钟域来的异步信号进入较快的时钟域比较有效，对于进入一个较慢的时钟域，则没有作用 。

### 如何防止亚稳态

亚稳态是指触发器无法在某个规定时间段内达到一个可确认的状态。当一个触发器进入亚稳态时，既无法预测该单元的输出电平，也无法预测何时输出才能稳定在某个正确的电平上。在这个稳定期间，触发器输出一些中间级电平，或者可能处于振荡状态，并且这种无用的输出电平可以沿信号通道上的各个触发器级联式传播下去。
解决方法：
1 降低系统时钟频率
2 用反应更快的FF
3 引入同步机制，防止亚稳态传播（可以采用前面说的加两级触发器）。
4 改善时钟质量，用边沿变化快速的时钟信号

### 什么是时钟抖动

时钟抖动是指芯片的某一个给定点上时钟周期发生暂时性变化，也就是说时钟周期在不同的周期上可能加长或缩短。它是一个平均值为0的平均变量。

### FPGA设计中对时钟的使用

FPGA芯片有固定的时钟路由，这些路由能有减少时钟抖动和偏差。需要对时钟进行相位移动或变频的时候，一般不允许对时钟进行逻辑操作，这样不仅会增加时钟的偏差和抖动，还会使时钟带上毛刺。一般的处理方法是采用FPGA芯片自带的时钟管理器如PLL,DLL或DCM，或者把逻辑转换到触发器的D输入（这些也是对时钟逻辑操作的替代方案）。



### 时钟抖动和时钟偏移的概念及产生原因，如何避免？

时钟抖动jitter:指时钟信号的跳变沿不确定，故是时钟频率上的不一致。
时钟偏移Skew:指全局时钟产生的各个子时钟信号到达不同触发器的时间点不同，是时钟相位的不一致。
jitter主要受外界干扰引起，通过各种抗干扰手段可以避免。而skew由数字电路内部各路径布局布线长度和负载不同导致，利用全局时钟网络可尽量将其消除。



### 跨时钟域



###  时序约束的概念和基本策略

时序约束主要包括周期约束，偏移约束，静态时序路径约束三种。通过附加时序约束可以综合布线工具调整映射和布局布线，使设计达到时序要求。
附加时序约束的一般策略是先附加全局约束，然后对快速和慢速例外路径附加专门约束。附加全局约束时，首先定义设计的所有时钟，对各时钟域内的同步元件进行分组，对分组附加周期约束，然后对FPGA/CPLD输入输出PAD附加偏移约束、对全组合逻辑的PAD TO PAD路径附加约束。附加专门约束时，首先约束分组之间的路径，然后约束快、慢速例外路径和多周期路径，以及其他特殊路径。

### 附加约束的作用

1：提高设计的工作频率（减少了逻辑和布线延时）；
2：获得正确的时序分析报告；（静态时序分析工具以约束作为判断时序是否满足设计要求的标准，因此要求设计者正确输入约束，以便静态时序分析工具可以正确的输出时序报告）
3：指定FPGA/CPLD的电气标准和引脚位置。



### FPGA内部逻辑



### 逻辑设计中竞争与冒险概念，如何识别与消除

​	**竞争**：在组合逻辑电路中，信号经过多条路径到达输出端，每条路径经过的逻辑门不同存在时差，在信号变化的瞬间存在先后顺序。这种现象叫竞争。

　　**冒险**：由于竞争而引起电路输出信号中出现了非预期信号，产生瞬间错误的现象称为冒险。表现为输出端出现了原设计中没有的窄脉冲，即毛刺。

　　常见的逻辑代数法判断是否有竞争冒险存在：只要输出逻辑表达式中含有某个信号的原变量A和反变量/A之间的“与”或者“或”关系，且A和/A经过不同的传播路径，则存在竞争。解决办法一是修改逻辑表达式避免以上情况，二是采样时序逻辑，仅在时钟边沿采样，三十在芯片外部并联电容消除窄脉冲。

### 格雷码特点及应用

连续的格雷码之间只有单比特信号变化，多用在异步时钟域处理上，如异步FIFO中地址指针的索引就采用格雷码编码。

　　分析：只有单比特信号跨时钟域时，我们能通过双触发器构成的同步器在另一个时钟域内得到有效脉冲，但多比特信号若采用同样的方法，会出现各个比特更新时刻不一致导致数据错误的情况。而在异步FIFO设计中，两侧信号属于不同时钟域，FIFO必须通过对比来自不同时钟域的读写地址指针数值给出空满指示信号，地址指针需要多个比特信号才能代表FIFO深度。格雷码的单比特变化特性正好适用于这一场合，使用单比特信号同步策略完全适用于格雷码。



### 锁存器（latch）和触发器（flip-flop）区别

电平敏感的存储器件称为锁存器。可分为高电平锁存器和低电平锁存器，用于不同时钟之间的信号同步。
有交叉耦合的门构成的双稳态的存储原件称为触发器。分为上升沿触发和下降沿触发。可以认为是两个不同电平敏感的锁存器串连而成。前一个锁存器决定了触发器的建立时间，后一个锁存器则决定了保持时间。

### FPGA芯片内有哪两种存储器资源

FPGA芯片内有两种存储器资源：一种叫BLOCK RAM,另一种是由LUT配置成的内部存储器（也就是分布式RAM）。BLOCK RAM由一定数量固定大小的存储块构成的，使用BLOCK RAM资源不占用额外的逻辑资源，并且速度快。但是使用的时候消耗的BLOCK RAM资源是其块大小的整数倍。
### FPGA中可以综合实现为RAM/ROM/CAM的三种资源及其注意事项

三种资源：BLOCK RAM，触发器（FF），查找表（LUT）；
注意事项：
1：在生成RAM等存储单元时，应该首选BLOCK RAM 资源；其原因有二：第一：使用BLOCK RAM等资源，可以节约更多的FF和4-LUT等底层可编程单元。使用BLOCK RAM可以说是“不用白不用”，是最大程度发挥器件效能，节约成本的一种体现；第二：BLOCK RAM是一种可以配置的硬件结构，其可靠性和速度与用LUT和REGISTER构建的存储器更有优势。
2：弄清FPGA的硬件结构，合理使用BLOCK RAM资源；
3：分析BLOCK RAM容量，高效使用BLOCK RAM资源；
4：分布式RAM资源（DISTRIBUTE RAM）

### 查找表的原理与结构

查找表（look-up-table）简称为LUT，LUT本质上就是一个RAM。目前FPGA中多使用4输入的LUT，所以每一个LUT可以看成一个有 4位地址线的16x1的RAM。 当用户通过原理图或HDL语言描述了一个逻辑电路以后，PLD/FPGA开发软件会自动计算逻辑电路的所有可能的结果，并把结果事先写入RAM,这样，每输入一个信号进行逻辑运算就等于输入一个地址进行查表，找出地址对应的内容，然后输出即可。
### MOORE 与 MEELEY状态机的特征？
Moore 状态机的输出仅与当前状态值有关, 且只在时钟边沿到来时才会有状态变化。
Mealy 状态机的输出不仅与当前状态值有关, 而且与当前输入值有关。

### 多时域设计中,如何处理信号跨时域？
不同的时钟域之间信号通信时需要进行同步处理，这样可以防止新时钟域中第一级触发器的亚稳态信号对下级逻辑造成影响。
信号跨时钟域同步：当单个信号跨时钟域时，可以采用两级触发器来同步；数据或地址总线跨时钟域时可以采用异步FIFO来实现时钟同步；第三种方法就是采用握手信号。

### 说说静态、动态时序模拟的优缺点？
静态时序分析是采用穷尽分析方法来提取出整个电路存在的所有时序路径，计算信号在这些路径上的传播延时，检查信号的建立和保持时间是否满足时序要求，通过对最大路径延时和最小路径延时的分析，找出违背时序约束的错误。它不需要输入向量就能穷尽所有的路径，且运行速度很快、占用内存较少，不仅可以对芯片设计进行全面的时序功能检查，而且还可利用时序分析的结果来优化设计，因此静态时序分析已经越来越多地被用到数字集成电路设计的验证中。
动态时序模拟就是通常的仿真，因为不可能产生完备的测试向量，覆盖门级网表中的每一条路径。因此在动态时序分析中，无法暴露一些路径上可能存在的时序问题；

### 同步复位的D触发器

同步复位的D触发器中的“同步”是和工作时钟同步的意思，也就是说，当时钟的上升沿（也可以是下降沿，一般习惯上为上升沿触发）来到时检测到按键的复位操作才有效，否则无效。

### 异步复位的D触发器

异步复位的D触发器中的“异步”是和工作时钟不同步的意思，也就是说，寄存器的复位不关心时钟的上升沿来不来，只要有检测到按键被按下，就立刻执行复位操作。

## 单位换算

1s

1ms（毫秒）=10^(-3) s

1um（微秒）=10^(-6) s

1ns（纳秒）=10^(-9) s

1ps（皮秒）=10^(-12) s

1fs（飞秒）=10^(-15) s

## verilog

### 基数表示法

1. 8’hab 表示 8bit 的十六进制数，换算成二进制是 1010_1011；
2. 8’d171 表示 8bit 的十进制数，换算成二进制是 1010_1011；
3. 8’o253 表示 8bit 的八进制数，换算成二进制是 1010_1011；
4. 8’b1010_1011 表示 8bit 的二进制数，二进制就是 1010_1011。

4’b11011011 和 4’b1101_1011 表示的是一样的值，但是后面的看上去更容易识别。

### 变量

1. **线网型（wire）**：表示电路间的物理连接；

2. **寄存器型（reg）**：Verilog 中一个抽象的数据存储单元。

（1）wire 可以看成直接的连接，在可综合的逻辑中会被映射成一

根真实的物理连线；

（2）而 reg 具有对某一个时间点状态进行保持的功能，如果在可综合的时序逻辑中表达，会被映射成一个真实的的物理寄存器，而在 Verilog 仿真器中，寄存器类型的变量通常要占据一个仿真内存空间。

（1）凡是在 **always** 或initial 语句中被赋值的变量（赋值号左边的变量），不论表达的是组合逻辑还是时序逻辑，都一定是 reg 型变量；

（1）凡是在 **assign** 语句中被赋值的变量，一定是 wire 型变量。

### 赋值语句

阻塞型过程赋值语句的执行过程是：首先计算赋值号右边的值，然后立即将计算结果赋值给左边，赋值语句结束，变量值立即发生改变。阻塞的概念是指在同一个always块中，其后面的赋值语句从概念上是在前一句赋值语句结束后再开始下面的赋值。

非阻塞赋值的赋值号用“<=”表示。为什么称这种赋值方式为非阻塞赋值呢？这是因为对应的电路结构往往与触发沿有关系，只有在触发沿的时刻才能进行非阻塞赋值。非阻塞操作开始时计算非阻塞赋值符的赋值号右边的语句，赋值操作结束时刻才更新赋值号左边的语句，可以认为是两个步骤（赋值开始时刻和结束时刻）来完成非阻塞赋 值。

**<=（非阻塞赋值）**

- 在 begin-end 串行语句块中，一条非阻塞过程语句的执行不会阻塞下一语句的执行，也就是说在本条非阻塞型过程赋值语句对应的赋值操作执行完之前，下一条语句也可以开始执行；
- 仿真过程在遇到非阻塞型过程赋值语句后首先计算其右端赋值表达式的值，然后等到仿真时间结束时再将该计算结果赋值变量。也就是说，这种情况下的赋值操作是在同一仿真时刻上的其他普通操作结束后才得以执行。
- 非阻塞操作只能用于对寄存器类型变量进行赋值，因此只能用于“initial”和“always”块中，不允许用于连续赋值“assign”。

**= （阻塞赋值）**

- 在 begin-end 串行语句块中的各条阻塞型过程赋值语句将以它们在顺序块后排列次序依次得到执行；

- 阻塞型过程赋值语句的执行过程是：首先计算右端赋值表达式的值，然后立即将计算结果赋值给“=”左端的被赋值变量。

  

### begin end 语句

 	对多条语句赋值时使用，因为我们设计RTL代码的原则是一个always块中最好只有一个变量，所以begin…end在RTL代码中几乎很少使用，而在Tetbench中使用的更多。

```
initial
begin //在仿真中begin...end块中的内容都是顺序执行的，
//在没有延时的情况下几乎没有差别，看上去是同时执行的，
//如果有延时才能表达的比较明了；
//而在rtl代码中begin...end相当于括号的作用，
//在同一个always块中给多个变量赋值的时候要加上
in1 <= 1'b0;
in2 <= 1'b0;
sel <= 1'b0;
end
```

### initial 

不可综合，常用于Testbech中初始化信号，但也可以在可综合的模块中用于初始化寄存器

```
//initial语句是可以被综合的，一般只在testbench中表达而不在RTL代码中表达
//initial块中的语句上电后只执行一次，主要用于初始化仿真中要输入的信号
//初始化值在没有特殊要求的情况下给0或1都可以。如果不赋初值，仿真时信号会显示为不定态（ModelSim中的波形显示红色）
```

## always和assign的区别

assign，

连续赋值，就是无条件全等。

always，

敏感赋值，就是有条件相等。



1. 一个always块只一个变量进行赋值

   ```
   因为always块是并行的，执行的顺序是随机的，综合时会报多驱动的错误，所以严禁在多个always块中对同一个变量赋值；当然也不推荐一个always对多个变量进行赋值，虽然这种方式是允许的，但如果过多会导致代码的混乱且不易后期的维护和修改
   ```

2. 在同一个always块中不要既要用非阻塞赋值又用阻塞方式赋值

   在同一个always块中对同一个变量既进行阻塞赋值又进行非阻塞赋值会产生综合不可预测的结果，不是可综合的Verilog风格。

3. 使用always块来编写组合逻辑的代码时要用阻塞赋值的方式

   使用always块建立组合逻辑电路模型时不要忘记always块中的敏感列表一定要使用电平触发的方式，然后在always块中使用阻塞赋值语句就可以实现组合逻辑，这样做既简单且方针又快又好，这样的风格是值得推荐的。

   

## Verilog 语言中的系统任务和系统函数

`timescale 1ns**/**1ns   //时间尺度预编译指令 **时间单位**/**时间精度**

## 触发器

参考文献：[四种常见触发器（RS触发器、JK触发器、D触发器、T触发器）的基本逻辑及其状态 - asandstar - 博客园 (cnblogs.com)](https://www.cnblogs.com/asandstar/p/16942910.html)

1. RS触发器（与非门和或非门构成）
2. D触发器（制作数据寄存器）
3. JK触发器（时钟触发器）
4. T触发器（翻转触发器，计数器）

### D触发器

- posedge是上升沿，电平从低到高跳变
- negedge是下降沿，电平从高到低跳变

#### 同步复位的D触发器

同步复位的D触发器中的“同步”是和工作时钟同步的意思，也就是说，当时钟的上升沿（也可以是下降沿，一般习惯上为上升沿触发）来到时检测到按键的复位操作才有效，否则无效。

```
 always@(posedge sys_clk) //当always块中的敏感列表为检测到sys_clk上升沿时
```

#### 异步复位的D触发器

异步复位的D触发器中的“异步”是和工作时钟不同步的意思，也就是说，寄存器的复位不关心时钟的上升沿来不来，只要有检测到按键被按下，就立刻执行复位操作。

```
always@(posedge sys_clk or negedge sys_rst_n)
```



## 锁存器（Latch）

Latch其实就是锁存器，是一种在异步电路系统中，对输入信号电平敏感的单元，用来存储信息。锁存器在数据未锁存时，输出端的信号随输入信号变化，就像信号通过一个缓冲器，一旦锁存信号有效，则数据被锁存，输入信号不起作用。因此，锁存器也被称为透明锁存器，指的是不锁存时输出对于输入是透明的。

### 1、Latch危害

之所以在这里讲关于Latch的问题是因为只有组合逻辑才会产生这种问题，产生Latch是我们在同步电路中尽量避免的，但并不表示Latch没有用的或者说是错误的，Latch在异步电路中是非常有用的，只是我们设计的是同步电路，要尽量避免。

1. 在同步电路中Latch会产生不好的效果，如对毛刺敏感；
2. 不能异步复位，上电后处于不定态；
3. 还会让静态时序分析变得十分复杂；
4. 在FPGA的资源中，大部分器件没有锁存器这个东西，所以需要用使用寄存器来组成锁存器所以会占用更多逻辑资源；
5. 在ASIC设计中，锁存器也会带来额外的延时和DFT，并不利于提高系统的工作频 率，所以要避免产生。

### 2、Latch产生的原因

1. 组合逻辑中if语句没有else；
2. 组合逻辑中case的条件不能够完全列举时且不写default；
3. 组合逻辑中输出变量赋值给自己。



## 译码器（decoder）

译码器（decoder）是一类多输入多输出组合逻辑电路器件。可分为变量译码和显示译码两类。

（1）变量译码器一般是一种较少输入变为较多输出的器件，常见的有n线-2^n线译码和8421BCD码译码两类。

（2）显示译码器用来将二进制数转换成对应的七段码，一般其可分为驱动LED和驱动LCD两类。



## 状态机

状态机简写为FSM（Finite State Machine），也称为**同步有限状态机**，我们一般简称为状态机，<font color=red>之所以说“同步”是因为状态机中所有的状态跳转都是在时钟的作用下进行的，而“有限”则是说状态的个数是有限的</font>。状态机根据影响输出的原因分为两大类，即Moore型状态机和Mealy型状态机，其共同点 是：状态的跳转都只和输入有关。区别主要是在输出的时候：<font color=blue>若最后的输出只和当前状态有关而与输入无关则称为Moore型状态机</font>；<font color=bisque>若最后的输出不仅和当前状态有关还和输入有关则称为Mealy型状态机</font>。状态机是时序逻辑电路中非常重要的一个应用，常在大型复杂的系统中使用较多。

状态机的每一个状态代表一个事件，从执行当前事件到执行另一事件我们称之为状态的跳转或状态的转移，我们需要做的就是执行该事件然后跳转到一下时间，这样我们的系统就“活”了，可以正常的运转起来了。有研究显示状态机可以描述除相对论和量子力学以外的任何事情，但特别适合描述那些发生有先后顺序或时序规律的事情，在数 字电路系统中小到计数器大到微处理器都可以用状态机来进行描述。



## 锁相环（PLL）



## verilog和systemVerilog以及System C的区别



